Problem 1: Use PULP to encode a linear programming problem.
This problem set will involve using a python library called PULP to formulate and solve linear programming problems.

Here is a documentation: https://www.coin-or.org/PuLP/pulp.html Examples are also attached in the tutorial that accompanies this week's reading materials.

As a "warm up" exercise, we are going to use pulp to solve a generic LP of the form

maxùóå.ùóç.ùëê0ùë•0+‚ãØ+ùëêùëõ‚àí1ùë•ùëõ‚àí1ùëé0,0ùë•0+‚ãØ+ùëé0,ùëõ‚àí1ùë•ùëõ‚àí1‚ãØùëéùëö‚àí1,0ùë•0+‚ãØ+ùëéùëö‚àí1,ùëõ‚àí1ùë•ùëõ‚àí1‚â§ùëè0‚ãÆ‚â§ùëèùëö‚àí1
Note that to make life easier for python programmers we will index starting from 0
. The LP has ùëõ
 decision variables ùë•0,‚Ä¶,ùë•ùëõ‚àí1
, and ùëö
 constraints.

The data for the problem will be given to you in the form of three lists:

list_c is a list of size n that has the objective coefficients.

list_c: [c0, ..., cn-1]
list_a is a list of ùëö
 lists where each element of list_a is itself a list of size ùëõ
. This represents all the coefficients.

list_a : [ [ a00, a01, ...., a0,n-1], 
           [ a10, a11, ...., a1,n-1], 
           ...
           [ am-1,0, ...., am-1,n-1] ]
Finally, list_b is a list of size ùëö
 that has the RHS coefficients of each inequality.

list_b : [ b0,..., bm-1]
Your goal is as follows:

Given list_c, list_a, and list_b, setup the linear programming problem in Pulp,
Solve it and
Return the result. The result is defined by a tuple of three things: (is_feasible, is_bounded, opt_sol).
is_feasible is a Boolean that is True if the LP is feasible and False otherwise.
is_bounded is a Boolean that is True if the LP is bounded and False otherwise. The value of is_bounded is meaningful only if is_feasible is True. If is_feasible is False, this value can be arbitrary.
opt_sol is a list of n values for decision variables ùë•0,ùë•1,‚Ä¶,ùë•ùëõ‚àí1
.
Note that opt_sol is meaningful only if is_feasible and is_bounded are both true. Failing these, the value of opt_sol can be arbitrary.
from pulp import *
‚Äã
def formulate_lp_problem(m, n, list_c, list_a, list_b):
    # Assert that the data is compatible.
    assert n > 0
    assert m > 0
    assert len(list_c) == n
    assert len(list_a) == len(list_b) and len(list_b) == m
    assert all(len(l) == n for l in list_a)
‚Äã
    # Create a LP Model 
    lpModel = LpProblem('LPProblem', LpMaximize)
‚Äã
    # Create all the decision variables and store all the decision variables in a list
    decision_vars = [ LpVariable(f'x{i}', None, None) for i in range(n) ] 
‚Äã
    # Create the objective function 
    lpModel += lpSum([list_c[i]*decision_vars[i] for i in range(n)])
‚Äã
    # Create all the constraints
    for i in range(m):
        lpModel += lpSum([list_a[i][j]*decision_vars[j] for j in range(n)]) <= list_b[i]
‚Äã
    # Solve the problem
    status = lpModel.solve()
‚Äã
    # Check the status of the solution
    is_feasible = status != LpStatusInfeasible
    is_bounded = status != LpStatusUnbounded
    opt_sol = [value(var) for var in decision_vars] if is_feasible and is_bounded else None
‚Äã
    return (is_feasible, is_bounded, opt_sol)
m = 4
n = 3
list_c = [1, 1, 1]
list_a = [ [2, 1, 2], [1, 0, 0], [0, 1, 0], [0, 0, -1]]
list_b = [5, 7, 9, 4]
(is_feas, is_bnded, sols) = formulate_lp_problem(m, n, list_c, list_a, list_b)
assert is_feas, 'The LP should be feasible -- your code returns infeasible'
assert is_bnded, 'The LP should be bounded -- your code returns unbounded '
print(sols)
assert abs(sols[0] - 2.0) <= 1E-04 , 'x0 must be 2.0'
assert abs(sols[1] - 9.0) <= 1E-04 , 'x1 must be 9.0'
assert abs(sols[2] + 4.0) <= 1E-04 , 'x2 must be -4.0'
print('Passed: 3 points!')
[2.0, 9.0, -4.0]
Passed: 3 points!
# Test 2: Unbounded problem
m = 5
n = 4 
list_c = [-1, 2, 1, 1]
list_a = [ [ 1, 0, -1, 2], [2, -1, 0, 1], [1, 1, 1, 1], [1, -1, 1, 1], [0, -1, 0, 1]]
list_b = [3, 4, 5, 2.5, 3]
(is_feas, is_bnded, sols) = formulate_lp_problem(m, n, list_c, list_a, list_b)
assert is_feas, "The LP should be feasible. But your code returns a status of infeasible."
assert not is_bnded, "The LP should be unbounded but your code returns a status of bounded."
print('Passed: 3 points')
Passed: 3 points
# Test 3: Infeasible problem
m = 4
n = 3
list_c = [1, 1, 1]
list_a = [ [-2, -1, -2], [1, 0, 0], [0, 1, 0], [0, 0, 1]]
list_b = [-8, 1, 1, 1]
(is_feas, is_bnded, sols) = formulate_lp_problem(m, n, list_c, list_a, list_b)
assert not is_feas, 'The LP should be infeasible -- your code returns feasible'
print('Passed: 3 points!')
Passed: 3 points!
# Test 4
n = 15
m = 16
list_c = [1]*n 
list_c[6] = list_c[6]+1
list_a = []
list_b = []
for i in range(n):
    lst = [0]*n
    lst[i] = -1
    list_a.append(lst)
    list_b.append(0)
list_a.append([1]*n)
list_b.append(1)
(is_feas, is_bnded, sols) = formulate_lp_problem(m, n, list_c, list_a, list_b)
assert is_feas, 'Problem is feasible but your code returned infeasible'
assert is_bnded, 'Problem is bounded but your code returned unbounded'
print(sols)
assert abs(sols[6] - 1.0)  <= 1E-03, 'Solution does not match expected one'
assert all( [abs(sols[i]) <= 1E-03 for i in range(n) if i != 6]) , 'Solution does not match expected one'
print('Passed: 3 points!')
[-0.0, -0.0, -0.0, -0.0, -0.0, -0.0, 1.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0, -0.0]
Passed: 3 points!
Problem 2: LP formulation for an investment problem
Welcome to the world of finance! We are interested in investing in a portfolio of various stocks where we wish to maximize the overall return (profit/gain) on the investment but at the same time we do not want our investment to be diversified and the Price-to-Earnings (PE) ratio to be not too high, etc.. in order to mitigate risk. In this problem, we will develop a portfolio using linear programming.

The total budget available is given to us as an input ùêµ>0
.
We are also given a set of possible stocks and the corresponding data. The data for each investment includes:
Expected return of each investment.
The current price/unit of the stock.
The last earnings/unit of the stock.
The market category of the investment: Commodities, Tech, HealthCare
Your goal is to formulate a linear programming problem for the given data in order to maximize the overall expected return subject to the following constraints:

The total cost of the investment must be less than or equal to ùêµ
.
We are only allowed by buy non-negative (‚â•0
) amounts of each stock (short selling is not allowed). You can buy fractions of a stock (it is interesting how that works but many online trading houses let you do that).
The investment must be balanced:
The amount invested in each market category should be less than or equal to 2/3rds of the total budget.
The amount invested in each market category should be at least 1/6ths of the total budget.
The price to earnings ratio of the overall portfolio should not exceed 15
.
(A) Formulate on example data.
Suppose we have the following six investments with IDs 1 -6 and the data (this data is purely fictional) as shown below:

ID123456StockIBMMETAAstra-ZenecaPfizerUnileverProcter-GamblePrice/Unit12928672.293852148Expected Return/Unit252031.534.50Earnings/Unit1.98.11.552.55.2CategoryTechTechHealthHealthCommoditiesCommodities
Let ùë•1,‚Ä¶,ùë•6
 be the decision variables wherein ùë•ùëñ
 is the number of units of stock ID ùëñ
 purchased.

Write down the expression for the objective function in terms of ùë•1,‚Ä¶,ùë•6
. Also, specify if we are to maximize or minimize it.

YOUR ANSWER HERE

Write down the constraint that expresses that the total cost of investment must be less than ùêµ=10,000
.

YOUR ANSWER HERE

Write down the constraints that the total investment in each category cannot exceed 2/3rds of the budget. You should write down three constraints one for each category.

YOUR ANSWER HERE

Write down the constraints that the total investment in each category must exceed 1/6ths of the budget. You should write down three constraints one for each category.

YOUR ANSWER HERE

Write down an expression for the price of the overall portfolio (you have already done so for one of the constraints you expressed above). Also write down an expression for the overall earnings of the portfolio.

YOUR ANSWER HERE

We wish to enforce the constraint that the overall Price/Earnings ratio of the portfolio cannot exceed 15. Write down the constraint as

Price‚â§15√óEarnings
YOUR ANSWER HERE

Complete the formulation of the optimization problem in Pulp. See the notes accompanying this weeks module for a tutorial on solving LPs using PULP. See also: https://machinelearninggeek.com/solving-linear-programming-using-python-pulp/

from pulp import *
# Create a linear programming model and set it to maximize its objective
# Read this example here: https://coin-or.github.io/pulp/CaseStudies/a_blending_problem.html
lpModel = LpProblem('InvestmentProblem', LpMaximize)
# Create a variable called x1 and set its bounds to be between 0 and infinity
x1 = LpVariable('x1', 0, None) 
# 1. Next create variables x2.. x6
# 2. Set the objective function: here is an example of how to do it. Use the 
# Create a linear programming model and set it to maximize its objective
lpModel = LpProblem('InvestmentProblem', LpMaximize)
‚Äã
# Create decision variables
x = [LpVariable(f'x{i}', 0, None) for i in range(1, 7)]
‚Äã
# Set the objective function
lpModel += 25*x[0] + 20*x[1] + 3*x[2] + 1.5*x[3] + 3*x[4] + 4.5*x[5]
‚Äã
# Add the constraints
B = 10000  # total budget
lpModel += 129*x[0] + 286*x[1] + 72.29*x[2] + 38*x[3] + 52*x[4] + 148*x[5] <= B  # total cost constraint
‚Äã
# category investment constraints
lpModel += 129*x[0] + 286*x[1] <= 2/3*B  # Tech
lpModel += 72.29*x[2] + 38*x[3] <= 2/3*B  # Health
lpModel += 52*x[4] + 148*x[5] <= 2/3*B  # Commodities
‚Äã
lpModel += 129*x[0] + 286*x[1] >= 1/6*B  # Tech
lpModel += 72.29*x[2] + 38*x[3] >= 1/6*B  # Health
lpModel += 52*x[4] + 148*x[5] >= 1/6*B  # Commodities
‚Äã
# price to earnings ratio constraint
total_price = 129*x[0] + 286*x[1] + 72.29*x[2] + 38*x[3] + 52*x[4] + 148*x[5]
total_earnings = 1.9*x[0] + 8.1*x[1] + 1.5*x[2] + 5*x[3] + 2.5*x[4] + 5.2*x[5]
lpModel += total_price <= 15 * total_earnings
‚Äã
# Solve the model and print the solutions
lpModel.solve()
for v in lpModel.variables():
    print(v.name, "=", v.varValue)
print("Objective value = ", value(lpModel.objective))
x1 = 33.830665
x2 = 0.0
x3 = 0.0
x4 = 104.45204
x5 = 32.051282
x6 = 0.0
Objective value =  1098.598531
assert  abs(value(lpModel.objective) - 1098.59) <= 0.1, "Test failed" 
Problem 3: Optimal Transport
Suppose we have piles of different sizes of raw material at various locations in a worksite.

The piles of raw material are given as follows:

ID01ùëõ‚àí1Coordinates(ùë•0,ùë¶0)(ùë•1,ùë¶1)‚ãÆ(ùë•ùëõ‚àí1,ùë¶ùëõ‚àí1)Weightùëä0ùëä1ùëäùëõ‚àí1
We need to plan to redistribute this pile to a new configuration that is also given in terms of the desired coordinates and weights.

ID01ùëö‚àí1Coordinates(ùë•‚Ä≤0,ùë¶‚Ä≤0)(ùë•‚Ä≤1,ùë¶‚Ä≤1)‚ãÆ(ùë•‚Ä≤ùëö‚àí1,ùë¶‚Ä≤ùëö‚àí1)Weightùëä‚Ä≤0ùëä‚Ä≤1ùëä‚Ä≤ùëö‚àí1
ProblemSet-fig-transportation.png

Example
As an example, consider the following data showing the starting configuration:
ID012Coordinates(1,5)(4,1)(5,5)Weight945
We wish to distribute the input pile so that we have the following output:
ID01Coordinates(2,2)(6,6)Weight99
Optimal Transport Problem
The cost of moving ùë§
 units of material from location (ùë•,ùë¶)
 to target location (ùë•‚Ä≤,ùë¶‚Ä≤)
 is given by

ùë§√ó(ùë•‚àíùë•‚Ä≤)2+(ùë¶‚àíùë¶‚Ä≤)2‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚àö
Our goal is to come up with a transportation plan that minimizes the overall cost of moving raw materials from a starting configuration to an ending configuration.

Example
Going back to our example, here is a transportation plan:

Move 5 units of raw material from (5,5) (location id 2) to (6,6) (target location id 1). This incurs a cost of 5√ó12+12‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚àö=52‚éØ‚éØ‚àö
 units.
Move 4 units of raw material from (4,1)
 to (6,6)
. This incurs a cost of 429‚éØ‚éØ‚éØ‚éØ‚àö
 units.
Move 9 units from (1,5) to (2,2). Cost is 910‚éØ‚éØ‚éØ‚éØ‚àö
 The total cost of our plan is 52‚éØ‚éØ‚àö+429‚éØ‚éØ‚éØ‚éØ‚àö+910‚éØ‚éØ‚éØ‚éØ‚àö‚âà57.072
 units.
The question is whether we can do better than this?

Linear Program Formulation
To evolve a linear programming formulation, first let's identify the decision variables.

Let ùë•ùëñ,ùëó
 denote the amount of material transported from source location ùëñ
 to target location ùëó
. Since 0‚â§ùëñ‚â§ùëõ‚àí1
 and 0‚â§ùëó‚â§ùëö‚àí1
, there are ùëö√óùëõ
 such decision variables.

Clearly ùë•ùëñ,ùëó‚â•0
 since it does not make any sense to transport negative amount of material.

Let ùê∑ùëñ,ùëó
 denote the distance from source location ùëñ
 to destination location ùëó
.

ùê∑ùëñ,ùëó=(ùë•ùëñ‚àíùë•‚Ä≤ùëó)2+(ùë¶ùëñ‚àíùë¶‚Ä≤ùëó)2‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚àö.
Write down the objective function in terms of ùë•ùëñ,ùëó
 and ùê∑ùëñ,ùëó
 for 1‚â§ùëñ‚â§ùëõ
 and 1‚â§ùëó‚â§ùëö
. Also indicate if we are going to maximize or minimize it.

YOUR ANSWER HERE

Next for each source location ùëñ
, the total amount of material transported from ùëñ
 to various destination locations must sum up to ùë§ùëñ
 : the total weight of material at location ùëñ
. Write down a constraint to enforce this.

YOUR ANSWER HERE

Next for each destination location ùëó
 , the total amount of material transported to ùëó
 from various source locations must sum up to ùë§‚Ä≤ùëó
 : the total weight of material at destination location ùëó
. Write down a constraint to enforce this.

YOUR ANSWER HERE

Formulate your optimization problem and return the optimal solution for given problem data:

source_coords: List of (x,y) pairs of coordinates for the source locations.
The size of the list is the number of source locations ùëõ
.
source_weights: List of ùë§ùëñ
 weights for the source location.
The size of the list equals number of source locations ùëõ
 and ùëñùë°‚Ñé
 element of this list is the weight corresponding to the ùëñùë°‚Ñé
 coordinate in the list source_coords.
Similarly we have two lists dest_coords and dest_weights. Note that sum(source_weights) must equal sum(dest_weights).

Your function should return the solution as a list of lists sol wherein sol[i][j] indicates the amount of material transported from source location i to destination location j.

Example
For instance, suppose our solution was as follows (here ùëõ=3,ùëö=4
):
ùë•0,0=0,ùë•0,1=5,ùë•0,2=7,ùë•0,3=0ùë•1,0=1,ùë•1,1=4,ùë•1,2=4,ùë•1,3=4ùë•2,0=4,ùë•2,1=5,ùë•2,2=5,ùë•2,3=5
[ [0, 5, 7, 0], 
  [1, 4, 4, 4], 
  [4, 5, 5, 5] 
 ]
from math import sqrt
def calculate_distance(a, b):
    (xa, ya) = a
    (xb, yb) = b
    return sqrt( (xa- xb)**2 + (ya - yb)**2)
    
def get_objective(var_values, source_coords, dest_coords):
    # A useful function for our test cases: please do not modify
    # It should help you in your code however to see how we calculate the objective function
    obj = sum([ var_values[i][j] * calculate_distance(source_coords[i], dest_coords[j])  for i in range(n) for j in range(m)  ])
    return obj 
‚Äã
def calculate_optimal_transport_plan(source_coords, source_weights, dest_coords, dest_weights):
    n = len(source_coords)
    assert (n== len(source_weights))
    m = len(dest_coords)
    assert (m == len(dest_weights))
    assert( sum(source_weights) == sum(dest_weights)) 
‚Äã
    #1. Create the LP model
    model = LpProblem("OptimalTransportPlan", LpMinimize)
‚Äã
    #2. Create a list of decision variables : x_{i,j} for i in range(n) and for j in range(m)
    x = [[LpVariable(f"x_{i}_{j}", 0) for j in range(m)] for i in range(n)]
‚Äã
    #3. Add the objective function
    model += lpSum([x[i][j] * calculate_distance(source_coords[i], dest_coords[j]) for i in range(n) for j in range(m)])
‚Äã
    #4. Add the constraints
    for i in range(n):
        model += lpSum([x[i][j] for j in range(m)]) == source_weights[i]
    for j in range(m):
        model += lpSum([x[i][j] for i in range(n)]) == dest_weights[j]
‚Äã
    #5. Solve and extract the solution/return it back in the required form to pass test cases
    model.solve()
    solution = [[x[i][j].varValue for j in range(m)] for i in range(n)]
    return solution
    
            
#Let's compute the solution for our example
source_coords = [ (1,5), (4,1), (5,5) ]
source_weights = [9, 4, 5]
dest_coords = [ (2,2), (6,6) ]
dest_weights = [9, 9]
n = 3
m = 2
var_values = calculate_optimal_transport_plan(source_coords, source_weights, dest_coords, dest_weights)
obj_val = get_objective(var_values, source_coords, dest_coords)
print(f'Objective value: {obj_val}')
## Check the solution
for i in range(n):
    assert ( sum(var_values[i][j] for j in range(m) ) == source_weights[i] )
for j in range(m):
    assert (sum(var_values[i][j] for i in range(n)) == dest_weights[j])
‚Äã
assert(abs(obj_val - 52.22) <= 1E-01)
print('Test Passed: 10 points')
Objective value: 52.22280607707767
Test Passed: 10 points
#Let's compute the solution for our example
source_coords = [ (1,1), (2,2), (3,3), (4, 4), (5,5), (6,6) ]
source_weights = [10, 10, 10, 10, 10, 10]
dest_coords = [ (6,1), (5, 2), (4,3), (3,2), (2,1) ]
dest_weights = [12, 12, 12, 12, 12]
n = 6
m = 5
var_values = calculate_optimal_transport_plan(source_coords, source_weights, dest_coords, dest_weights)
obj_val = get_objective(var_values, source_coords, dest_coords)
print(f'Objective value: {obj_val}')
## Check the solution
for i in range(n):
    assert ( sum(var_values[i][j] for j in range(m) ) == source_weights[i] )
for j in range(m):
    assert (sum(var_values[i][j] for i in range(n)) == dest_weights[j])
assert(abs(obj_val - 127.19) <= 1E-1)
print('Test Passed: 8 points')
Objective value: 127.19048316123448
Test Passed: 8 points
#Let's compute the solution for our example
source_coords = [ (i,1) for i in range(20) ]
source_weights = [10] * 20
dest_coords = [ (6,i+5) for i in range(8) ] + [ (14,i+5) for i in range(8) ] 
dest_weights = [12.5]*16
n = 20
m = 16
var_values = calculate_optimal_transport_plan(source_coords, source_weights, dest_coords, dest_weights)
obj_val = get_objective(var_values, source_coords, dest_coords)
print(f'Objective value: {obj_val}')
## Check the solution
for i in range(n):
    assert ( sum(var_values[i][j] for j in range(m) ) == source_weights[i] )
for j in range(m):
    assert (sum(var_values[i][j] for i in range(n)) == dest_weights[j])
assert(abs(obj_val - 1598.11) <= 1E-1)
print('Test Passed: 5 points')
Objective value: 1598.1136673805286
Test Passed: 5 points
Problem 3B (Optimal Pricing Model)
Let us consider a variant of the optimal transportation problem where we have the same data including the starting and desired configurations.

Source locations given as coordinates and weights : (ùë•ùëñ,ùë¶ùëñ),ùë§ùëñ
, ùëñ=1,‚Ä¶,ùëõ
.
Target locations given as coordinates and weights: (ùë•‚Ä≤ùëó,ùë¶‚Ä≤ùëó),ùë§‚Ä≤ùëó
, ùëó=1,‚Ä¶,ùëö
.
The cost of transporting a unit weight from source location ùëñ
 to target location ùëó
 is given by the Euclidean distance:
ùê∑ùëñ,ùëó: (ùë•ùëñ‚àíùë•‚Ä≤ùëó)2+(ùë¶ùëñ‚àíùë¶‚Ä≤ùëó)2‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚àö
Instead of deriving the transportation plan, we will focus on setting purchase/sale prices at the source and target locations respectively.

Suppose, we are allowed to set prices at the source and target locations for the material such that at each source location ùëñ
 we set a price ùëùùëñ
 per unit of the material and at each target location ùëó
, we set a price ùëù‚Ä≤ùëó
 per unit of the material. However, we cannot set the prices arbitrarily. We have to follow the following constraint:

For each source location ùëñ
 and target location ùëó
 the price difference ùëù‚Ä≤ùëó‚àíùëùùëñ
 must be less than or equal to ùê∑ùëñ,ùëó
.
Although this constraint sounds strange, it can be justified from economic arguments. Imagine for some source ùëñ
 and destination ùëó
, we have ùëù‚Ä≤ùëó‚àíùëùùëñ>ùê∑ùëñ,ùëó
 (we are making a strictly positive profit). Then a competitor can undercut us by buying at a higher price and/or selling at a lower price and thus take the business away from us. Perhaps, we try to undercut the competitor until finally, we have jointly driven the prices down to satisfy ùëù‚Ä≤ùëó‚àíùëùùëñ‚â§ùê∑ùëñ,ùëó
.

Once the prices have been setup at the source and target locations, the revenue we earn by transporting goods is given by

‚àëùëó=1ùëöùëù‚Ä≤ùëóùë§‚Ä≤ùëó‚àí‚àëùëñ=1ùëõùëùùëñùë§ùëñ
The first term is what we get by selling at the target location and the second term is what we get from buying at the source locations.

Formulate a LP that will set prices so that we maximize the revenue while satisfying the "economic" constraint above.

Problem data is same as before:

source_coords: List of (x,y) pairs of coordinates for the source locations.
The size of the list is the number of source locations ùëõ
.
source_weights: List of ùë§ùëñ
 weights for the source location.
The size of the list equals number of source locations ùëõ
 and ùëñùë°‚Ñé
 element of this list is the weight corresponding to the ùëñùë°‚Ñé
 coordinate in the list source_coords.
Similarly we have two lists dest_coords and dest_weights. Note that sum(source_weights) must equal sum(dest_weights).

Your function should return the solution as pair of two lists: (source_prices, target_prices). source_prices should have length n and target_prices should have length m.

from pulp import *
from math import sqrt
‚Äã
def calculate_distance(a, b):
    (xa, ya) = a
    (xb, yb) = b
    return sqrt((xa - xb)**2 + (ya - yb)**2)
‚Äã
def compute_optimal_prices(source_coords, source_weights, dest_coords, dest_weights):
    n = len(source_coords)
    assert (n == len(source_weights))
    m = len(dest_coords)
    assert (m == len(dest_weights))
    assert (sum(source_weights) == sum(dest_weights))
‚Äã
    # Define LP model
    lpModel = LpProblem('Transportation', LpMaximize)
‚Äã
    # Define decision variables
    source_vars = [LpVariable(f"p_{i}", lowBound=0) for i in range(n)]
    dest_vars = [LpVariable(f"p'_{j}", lowBound=0) for j in range(m)]
‚Äã
    # Define objective function
    lpModel += sum(dest_vars[j] * dest_weights[j] for j in range(m)) - sum(source_vars[i] * source_weights[i] for i in range(n))
‚Äã
    # Add constraints
    for i in range(n):
        for j in range(m):
            lpModel += dest_vars[j] - source_vars[i] <= calculate_distance(source_coords[i], dest_coords[j])
‚Äã
    lpModel.solve()
    source_prices = [v.varValue for v in source_vars]
    dest_prices = [v.varValue for v in dest_vars]
    return (source_prices, dest_prices)
#Let's compute the solution for our example
source_coords = [ (1,5), (4,1), (5,5) ]
source_weights = [9, 4, 5]
dest_coords = [ (2,2), (6,6) ]
dest_weights = [9, 9]
n = 3
m = 2
(source_prices, dest_prices) = compute_optimal_prices(source_coords, source_weights, dest_coords, dest_weights)
profit = sum([pi*wi for (pi, wi) in zip(dest_prices, dest_weights)]) - sum([pj*wj for (pj, wj) in zip(source_prices, source_weights)])
assert(abs(profit - 52.22) <= 1E-01), f'Error: Expected profit is {52.22} obtained: {profit}'
print('Test Passed: 7 points')
Test Passed: 7 points
#Let's compute the solution for our example
source_coords = [ (i,1) for i in range(20) ]
source_weights = [10] * 20
dest_coords = [ (6,i+5) for i in range(8) ] + [ (14,i+5) for i in range(8) ] 
dest_weights = [12.5]*16
n = 20
m = 16
(src_prices, dest_prices) = compute_optimal_prices(source_coords, source_weights, dest_coords, dest_weights)
profit = sum([pi*wi for (pi, wi) in zip(dest_prices, dest_weights)]) - sum([pj*wj for (pj, wj) in zip(src_prices, source_weights)])
assert(abs(profit - 1598.11) <= 1E-1), f'Error: Expected profit is {1598.11} obtained: {profit}'
print('Test Passed: 8 points')
Test Passed: 8 points
That's All Folks!¬∂
